(defun tree-every (tree fn)
  (cond ((atom tree)
	 (funcall fn tree))
	(t (every (lambda(el) (tree-every el fn)) tree))))

(defun tree-replace (tree replacement-fn)
  (cond ((atom tree)
	 (funcall replacement-fn tree))
	(t (mapcar (lambda(el) (tree-replace el replacement-fn)) tree))))

  
(defun filter-schulz-axioms ()
  (let ((in-use (active-iris *bfo2*)))
    (with-open-file (i "bfo:src;ontology;owl-group;build-artifacts;raw-schulz-axioms.lisp")
      (with-open-file (o "bfo:src;ontology;owl-group;build-artifacts;filtered-schulz-axioms.lisp" :direction :output :if-does-not-exist :create :if-exists :supersede)
	(loop with auto
	   for ax = (eval-uri-reader-macro (read i nil :eof))
	   until (eq ax :eof)
	   if (tree-every ax (lambda(el) (or (not (uri-p el)) (assoc el in-use) (eq el !owl:Thing))))
	   collect (tree-replace ax (lambda(el) (or (second (assoc el in-use)) el)))
	   into ok
	   else collect (tree-replace ax (lambda (el) (or (car (find el (cdr (bfo-uris *bfo2*)) :key 'third)) el)))
	   into notok
	   finally
	   (let ((*print-case* :downcase))
	     (loop for ax in ok
		if (or (and (eq (first ax) 'sub-class-of) (symbolp (second ax)) (symbolp (third ax)))
		       (and (eq (first ax) 'sub-object-property-of) (symbolp (second ax)) (symbolp (third ax)))
		       (and (eq (first ax) 'inverse-object-properties) (symbolp (second ax)) (symbolp (third ax)))
		       (and (eq (first ax) 'disjoint-classes))
		       (and (eq (first ax) 'equivalent-classes) (symbolp (second ax)) (consp (third ax)) (eq (first (third ax)) 'object-union-of)))
		do (push ax auto)
		else do
		  (print ax o) (terpri o))
	     (terpri o) (terpri o)
	     (format o ";; The following axioms are generated directly from structures in bfo2-reference.lisp~%~%")
	     (loop for ax in auto do (format o ";;~a~%~%" ax))
	     (format o ";; The following axioms use URIs not in the current spec~%~%")
	     (loop for ax in notok do (format o ";;~a~%~%" ax)))
	   (return (list ok notok)))))))

(defun read-and-process-axioms (bfo2 path)
  (with-open-file (f path )
    (loop with axs
       for form = (read f nil :eof) 
       until (eq form :eof)
       do (cond ((eq (car form) 'object-property)
		 (setq axs (append axs (translate-object-property-axioms bfo2 form)))))
       finally (return axs))))

(defun translate-object-property-axioms (bfo2 form)
  (with-bfo-uris bfo2
    (let* ((arity (second form))
	   (prop> (third form))
	   (prop< (when (consp prop>) (prog1 (second prop>) (setq prop> (first prop>)))))
	   (inverses? (second (assoc 'inverses (cdddr form)))))
      (setq prop> (eval prop>))
      (setq prop< (eval prop<))
      (loop for expression in (cdddr form)
	 append
	 (process-one-object-property-expression bfo2 form expression prop> prop< inverses?)))))

(defun process-one-object-property-expression (bfo2 form expression prop> prop< inverses? &aux axs)
  (with-bfo-uris bfo2
    (unless (eq (first expression) 'temporal)
      (if (eq (first expression) '<)
	  (loop for expr in (rest expression)
	     do (setq axs (append (process-one-object-property-expression bfo2 form expr prop< prop> inverses?)
				  axs)))
	  (if (member (second expression) '(<- -> <->))
	      (destructuring-bind (from operator to &rest keys) expression
		(let ((from (class-expressionize from))
		      (to (class-expressionize to)))
		  (cond ((eq operator '->)
			 (push `(sub-class-of ,@(maybe-object-property-annotations keys) ,from (object-all-values-from ,prop> ,to)) axs))
			((eq operator '<-)
			 (push `(sub-class-of ,@(maybe-object-property-annotations keys) ,to (object-all-values-from ,prop> ,from)) axs))
			((eq operator '<->)
			 (push `(sub-class-of ,@(maybe-object-property-annotations keys) ,from (object-all-values-from ,prop> ,to)) axs)
			 (unless (eq from to)
			   (push `(sub-class-of ,@(maybe-object-property-annotations keys) ,to (object-all-values-from ,prop> ,from)) axs)))
			)))
	      (let ((feature (first expression))
		    (classex (class-expressionize (second expression))))
		(cond ((eq feature 'domain)
		       (push `(object-property-domain ,@(maybe-object-property-annotations (cddr expression)) ,prop> ,classex) axs)
		       (and inverses? prop< (push `(object-property-range ,@(maybe-object-property-annotations (cddr expression)) ,prop< ,classex) axs)))
		      ((eq feature 'range)
		       (push `(object-property-range ,@(maybe-object-property-annotations (cddr expression)) ,prop> ,classex) axs)
		       (and inverses? prop< (push `(object-property-domain ,@(maybe-object-property-annotations (cddr expression)) ,prop< ,classex) axs)))
		      ((eq feature 'transitive)
		       (push `(transitive-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop>) axs))
		      ((eq feature 'functional)
		       (push `(functional-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop>) axs)
		       (and inverses? prop< (push `(inverse-functional-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop<) axs)))
		      ((eq feature 'inverse-functional)
		       (push `(inverse-functional-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop>) axs)
		       (and inverses? prop< (push `(functional-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop<) axs)))
		      ((eq feature 'symmetric)
		       (push `(symmetric-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop>) axs)
		       (and inverses? prop< (push `(symmetric-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop< ) axs)))
		      ((eq feature 'irreflexive)
		       (push `(irreflexive-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop>) axs)
		       (and inverses? prop< (push `(irreflexive-object-property ,@(maybe-object-property-annotations (cdr expression)) ,prop< ) axs)))
		      ))))
      axs)))

(defun maybe-object-property-annotations (keys)
  (when (getf keys :id)
    `((annotation !axiomid ,(make-uri nil (format nil "obo:bfo/axiom/~a" (getf keys :id)))))))

(defun class-expressionize (form)
  (cond ((eq form 'thing) !owl:Thing)
	((eq form 'nothing) !owl:Nothing)
	((eq form 'self) 'self-not-yet)
	((atom form) form)
	((eq (car form) 'or)
	 `(object-union-of ,@(mapcar 'class-expressionize (cdr form))))
	((eq (car form) 'and)
	 `(object-intersection-of ,@(mapcar 'class-expressionize (cdr form))))
	((eq (car form) 'some)
	 `(object-some-values-from ,(second form) ,(class-expressionize (third form))))
	((eq (car form) 'all)
	 `(object-all-values-from ,(second form) ,(class-expressionize (third form))))
	(t (error "don't understand expression ~a" form))))
  
; for debugging
'(defmacro object-property ( &whole form &rest all)
  (translate-object-property-axioms b form))

